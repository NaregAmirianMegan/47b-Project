<!DOCTYPE html>
<html>

  <body>

    <h1><strong>Representation:</strong></h1>
      <ul>
        <li>Each block will be a Block object</li>
        <li>The board state is represented in two forms: a list of Block objects and a 2D array of integers.</br>
        This is contained in the Board object</li>
        <li>The problem as a whole will be represented by Nodes each containing:
          <ul>
            <li>Current Board state</li>
            <li>Reference to parent Node</li>
            <li>g-value and h-value to compute f-value for IDA* (or some other) algorithm held within each board object</li>
          </ul>
        </li>
      </ul>
    <h1><strong>Check Success:</strong></h1>
      <ul>
        <li>Use 2-D array representation in Board objects to compare Node state to goal state</li>
      </ul>
    <h1><strong>Generate Possible Moves:</strong></h1>
      <ul>
        <li>Proceed block by block</li>
        <li>First collect row available moves</li>
        <li>Then collect column available moves</li>
      </ul>
    <h1><strong>Choose Move:</strong></h1>
      <ul>
        <li>Choose the move with the lowest f-value</li>
      </ul>
    <h1><strong>Change Game State:</strong></h1>
      <ul>
        <li>Moves are represented in the Move object; it contains a boolean indicating column or row movement</br>
        as well as which block to move and how many spaces to move it.</li>
        <li>A Move instance can be passed into a Board constructor to create a new Board instance with the effect of</br>
        that move.</li>
      </ul>
    <h1><strong>Store Previous Game States:</strong></h1>
      <ul>
        <li>Certain graph search algorithms like A* use a queue to remember previously visited nodes to</br>
        prevent infinite cycling; however, for larger sample cases a depth first search would be better if you</br>
        are remembering previous states (to conserve space complexity).</li>
      </ul>

  </body>

</html>
